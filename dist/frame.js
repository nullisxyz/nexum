import{e as m}from"./assets/events-CXH2uRM3.js";const w="__frameAppearAsMM__";function y(s){const e=window.localStorage.getItem(s);if(e&&typeof e=="string")try{return JSON.parse(e)}catch(n){return console.debug("Error parsing the local setting",n),!1}return!1}class l extends m.EventEmitter{_inSetup=!0;constructor(){super(),this.handleMessage=this.handleMessage.bind(this),console.debug("[Eip1193Connection] Initializing Eip1193Connection instance"),window.addEventListener("message",this.handleMessage),console.debug('[Eip1193Connection] Emitting "connect" event'),setTimeout(()=>this.emit("connect"),0),this._inSetup=!1,console.debug("[Eip1193Connection] Initialization complete, inSetup:",this._inSetup)}handleMessage(e){if(console.debug("[Eip1193Connection] Message received:",e),e&&e.source===window&&e.data){const{type:n,payload:t,event:i,args:o}=e.data;n==="eth:payload"&&(console.debug("[Eip1193Connection] Handling payload message:",t),this.emit("payload",t)),n==="eth:event"&&(console.debug(`[Eip1193Connection] Handling event message: ${i}`,o),this.emit(i,...o))}else console.warn("[Eip1193Connection] Received an invalid or unexpected message:",e)}async send(e){console.debug("[Eip1193Connection] Sending payload:",e),window.postMessage({type:"eth:send",payload:e},window.location.origin)}close(){console.debug("[Eip1193Connection] Closing connection and removing event listener"),window.removeEventListener("message",this.handleMessage)}get inSetup(){return console.debug("[Eip1193Connection] Checking inSetup status:",this._inSetup),this._inSetup}}function C(s,e=[],n,t){const i={id:n,method:s,params:e,jsonrpc:"2.0"};return t&&(i.chainId=t),i.method==="eth_sendTransaction"?(M(i),L(i)):i}function M(s){const e=s.params[0]||{};if(s.method!=="eth_sendTransaction"||!("chainId"in e))return!1;const n=e.chainId,t=parseInt(n),i=parseInt(s.chainId||n);if(t!==i)throw new Error(`Transaction chain id (${t}) inconsistent with specified target chain id (${i})`)}function L(s){const e=s.params[0]||{};return{...s,params:[{...e,chainId:e.chainId||s.chainId},...s.params.slice(1)]}}class P extends m.EventEmitter{connection;eventHandlers;promises={};attemptedSubscriptions=new Set;subscriptions=[];networkVersion;manualChainId;providerChainId;checkConnectionRunning=!1;checkConnectionTimer;nextId=1;connected=!1;accounts=[];selectedAddress=void 0;coinbase=void 0;status="disconnected";constructor(e){super(),console.debug("[Provider] Initializing Provider"),this.enable=this.enable.bind(this),this.doSend=this.doSend.bind(this),this.send=this.send.bind(this),this.sendBatch=this.sendBatch.bind(this),this.subscribe=this.subscribe.bind(this),this.unsubscribe=this.unsubscribe.bind(this),this.resumeSubscriptions=this.resumeSubscriptions.bind(this),this.sendAsync=this.sendAsync.bind(this),this.sendAsyncBatch=this.sendAsyncBatch.bind(this),this.isConnected=this.isConnected.bind(this),this.close=this.close.bind(this),this.request=this.request.bind(this),this.connection=e,this.on("connect",this.resumeSubscriptions),this.connection.on("connect",()=>{console.debug("[Provider] Connector connected"),this.checkConnection(1e3)}),this.connection.on("close",()=>{console.debug("[Provider] Connector closed"),this.connected=!1,this.attemptedSubscriptions.clear(),this.emit("close"),this.emit("disconnect")}),this.connection.on("payload",n=>{console.debug(`[Provider] Received payload: ${JSON.stringify(n)}`);const{id:t,method:i,error:o,result:r}=n;if(typeof t<"u"){if(this.promises[t]){const d=this.promises[t].method;if(console.debug(`[Provider] Fulfilling promise for request method: ${d}`),d&&["eth_accounts","eth_requestAccounts"].includes(d)){const c=r||[];this.accounts=c,this.selectedAddress=c[0],this.coinbase=c[0],console.debug(`[Provider] Accounts updated: ${JSON.stringify(c)}`)}n.error?(console.error(`[Provider] Payload error: ${JSON.stringify(o)}`),this.promises[t].reject(o)):this.promises[t].resolve(r),delete this.promises[t]}}else i&&i.indexOf("_subscription")>-1&&(console.debug(`[Provider] Subscription event: ${i}`),this.emit(n.params.subscription,n.params.result),this.emit(i,n.params),this.emit("message",{type:n.method,data:{subscription:n.params.subscription,result:n.params.result}}),this.emit("data",n))}),this.on("newListener",n=>{console.debug(`[Provider] New listener added for event: ${n}`),Object.keys(this.eventHandlers).includes(n)&&!this.attemptedSubscription(n)&&this.connected&&(this.startSubscription(n),n==="networkChanged"&&console.warn("[Provider] The networkChanged event is deprecated, use chainChanged instead"))}),this.eventHandlers={networkChanged:n=>{console.debug(`[Provider] Network changed: ${n}`),this.networkVersion=typeof n=="string"?parseInt(n):n,this.emit("networkChanged",this.networkVersion)},chainChanged:n=>{console.debug(`[Provider] Chain changed: ${n}`),this.providerChainId=n,this.manualChainId||this.emit("chainChanged",n)},chainsChanged:n=>{console.debug(`[Provider] Chains changed: ${JSON.stringify(n)}`),this.emit("chainsChanged",n)},accountsChanged:n=>{console.debug(`[Provider] Accounts changed: ${JSON.stringify(n)}`),this.selectedAddress=n[0],this.emit("accountsChanged",n)}}}get chainId(){return this.manualChainId||this.providerChainId}get inSetup(){return console.debug(`[Provider] inSetup: ${this.connection.inSetup}`),this.connection.inSetup}async checkConnection(e=4e3){if(console.debug(`[Provider] Checking connection, retry timeout: ${e}`),!(this.checkConnectionRunning||this.connected)){clearTimeout(this.checkConnectionTimer),this.checkConnectionTimer=void 0,this.checkConnectionRunning=!0;try{this.networkVersion=await this.doSend("net_version",[],void 0,!1),this.providerChainId=await this.doSend("eth_chainId",[],void 0,!1),console.debug(`[Provider] Network version: ${this.networkVersion}, Chain ID: ${this.providerChainId}`),this.connected=!0}catch(n){console.error(`[Provider] Connection check failed ${JSON.stringify(n)}, retrying in ${e}ms`),this.checkConnectionTimer=setTimeout(()=>this.checkConnection(),e),this.connected=!1}finally{this.checkConnectionRunning=!1,this.connected&&this.emit("connect",{chainId:this.providerChainId})}}}attemptedSubscription(e){return this.attemptedSubscriptions.has(e)}setSubscriptionAttempted(e){this.attemptedSubscriptions.add(e)}async startSubscription(e){console.debug(`[Provider] Starting subscription for event: ${e}`),this.setSubscriptionAttempted(e);try{const n=await this.subscribe("eth_subscribe",e);console.debug(`[Provider] Subscription started, event ID: ${n}`),this.on(n,this.eventHandlers[e])}catch(n){console.warn(`[Provider] Unable to subscribe to ${e}`,n)}}resumeSubscriptions(){console.debug("[Provider] Resuming subscriptions"),Object.keys(this.eventHandlers).forEach(e=>{this.listenerCount(e)&&!this.attemptedSubscription(e)&&this.startSubscription(e)})}async enable(){console.debug("[Provider] Enabling provider");const e=await this.doSend("eth_accounts");if(e.length>0)return this.accounts=e,this.selectedAddress=e[0],this.coinbase=e[0],console.debug(`[Provider] Accounts enabled: ${JSON.stringify(e)}`),this.emit("enable"),e;{class n extends Error{code}const t=new n("User Denied Full Provider");throw t.code="4001",t}}doSend(e,n=[],t=this.manualChainId,i=!0){console.debug(`[Provider] Sending request: ${JSON.stringify(e)}`);const o=(r,d)=>{const c=typeof e=="object"?e.method:e,u=typeof e=="object"?e.params:n,v=typeof e=="object"&&e.chainId||t;if(!c)return console.error("[Provider] Method is invalid"),d(new Error("Method is not a valid string."));try{const h=C(c,u,this.nextId++,v);console.debug(`[Provider] Payload created: ${JSON.stringify(h)}`),this.promises[h.id]={resolve:S=>r(S),reject:d,method:h.method},this.connection.send(h)}catch(h){console.error(`[Provider] Error sending payload: ${h.message}`),d(h)}};return this.connected||!i?new Promise(o):new Promise((r,d)=>{const c=()=>(clearTimeout(u),r(new Promise(o))),u=setTimeout(()=>{console.error("[Provider] Timed out waiting for connection"),this.off("connect",c),d(new Error("Not connected"))},5e3);this.once("connect",c)})}async send(e,n){if(console.debug(`[Provider] Sending method or payload: ${JSON.stringify(e)}`),typeof e=="string"&&(!n||Array.isArray(n))){const t=n;return this.doSend(e,t)}if(e&&typeof e=="object"&&typeof n=="function"){const t=n;return this.sendAsync(e,t)}return this.request(e)}sendBatch(e){return console.debug(`[Provider] Sending batch of requests: ${JSON.stringify(e)}`),Promise.all(e.map(n=>this.doSend(n.method,n.params)))}async subscribe(e,n,t=[]){console.debug(`[Provider] Subscribing to method: ${n} with params: ${JSON.stringify(t)}`);const i=await this.doSend(e,[n,...t]);return this.subscriptions.push(i),console.debug(`[Provider] Subscription ID: ${i}`),i}async unsubscribe(e,n){console.debug(`[Provider] Unsubscribing from ID: ${n}`);const t=await this.doSend(e,[n]);if(t)return this.subscriptions=this.subscriptions.filter(i=>i!==n),this.removeAllListeners(n),console.debug(`[Provider] Unsubscribed successfully from ID: ${n}`),t}async sendAsync(e,n){if(console.debug(`[Provider] Sending async payload: ${JSON.stringify(e)}`),!n||typeof n!="function"){const t=new Error("Invalid or undefined callback provided to sendAsync");return console.error(`[Provider] ${t.message}`),t}if(!e){const t=new Error("Invalid Payload");return console.error(`[Provider] ${t.message}`),n(t)}if(Array.isArray(e)){const t=e.map(o=>({...o,jsonrpc:"2.0"})),i=n;return this.sendAsyncBatch(t,i)}else{const t={...e,jsonrpc:"2.0"},i=n;try{const o=await this.doSend(t.method,t.params);console.debug(`[Provider] Async result: ${JSON.stringify(o)}`),i(null,{id:t.id,jsonrpc:t.jsonrpc,result:o})}catch(o){console.error(`[Provider] Async send failed: ${o.message}`),i(o)}}}async sendAsyncBatch(e,n){console.debug(`[Provider] Sending async batch: ${JSON.stringify(e)}`);try{const i=(await this.sendBatch(e)).map((o,r)=>({id:e[r].id,jsonrpc:e[r].jsonrpc,result:o}));console.debug(`[Provider] Async batch results: ${JSON.stringify(i)}`),n(null,i)}catch(t){console.error(`[Provider] Async batch send failed: ${t.message}`),n(t)}}isConnected(){return console.debug(`[Provider] Checking if connected: ${this.connected}`),this.connected}close(){console.debug("[Provider] Closing provider"),this.connection&&this.connection.close&&this.connection.close(),this.off("connect",this.resumeSubscriptions),this.connected=!1;const e=new Error("Provider closed, subscription lost, please subscribe again.");this.subscriptions.forEach(n=>this.emit(n,e)),this.subscriptions=[],this.manualChainId=void 0,this.providerChainId=void 0,this.networkVersion=void 0,this.selectedAddress=void 0,this.coinbase=void 0}async request(e){return console.debug(`[Provider] Requesting with payload: ${JSON.stringify(e)}`),this.doSend(e.method,e.params,e.chainId)}setChain(e){console.debug(`[Provider] Setting chain to: ${e}`),typeof e=="number"&&(e="0x"+e.toString(16));const n=e!==this.chainId;this.manualChainId=e,n&&(console.debug(`[Provider] Chain changed to: ${this.chainId}`),this.emit("chainChanged",this.chainId))}}function b(){Object.getOwnPropertyDescriptor(window,"ethereum")?.configurable?Object.defineProperty(window,"ethereum",{value:a,writable:!0,configurable:!0,enumerable:!0}):window.ethereum=a}class g extends P{doSend(e,n=[],t=this.manualChainId,i=!0){const o=typeof e=="string"?e:e.method;if(!i&&(o==="eth_chainId"||o==="net_version")){const r={jsonrpc:"2.0",id:this.nextId++,method:o,params:n,__extensionConnecting:!0};return new Promise((d,c)=>{this.promises[r.id]={resolve:d,reject:c,method:o},this.connection.send(r)})}return super.doSend(e,n,t,i)}}const I=y(w);let a;if(I){class s extends g{isMetaMask=!0;_metamask={isUnlocked:()=>new Promise(n=>n(!0))};constructor(n){super(n)}}try{a=new s(new l),a.setMaxListeners(0)}catch(e){console.error("Frame Error:",e)}}else{class s extends g{isFrame=!0}try{a=new s(new l),a.setMaxListeners(0)}catch(e){console.error("Frame Error:",e)}}const N={uuid:"d7acc008-6411-5486-bb2d-0c0cfcddbb92",name:"Frame",icon:"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDcuNSIgaGVpZ2h0PSIzMDYiIHZpZXdCb3g9IjAgMCAzMDcuNSAzMDYiPgogIDxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiMyODI3MmEiPjwvcmVjdD4KICA8cGF0aCBmaWxsPScjMDBkMmJlJyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3NywgNzYuNSkiIGQ9Ik0xNDUuMSw3NS42VjE3LjZjMC01LjEtNC4yLTkuMy05LjMtOS4zaC01OC4xYy0uNiwwLTEuMS0uMi0xLjYtLjZsLTctN2MtLjQtLjQtMS0uNy0xLjYtLjdIOS4zQzQuMiwwLDAsNC4xLDAsOS4zaDB2NThjMCwuNi4yLDEuMS42LDEuNmw3LDdjLjQuNC43LDEsLjcsMS42djU4YzAsNS4xLDQuMiw5LjMsOS4zLDkuM2g1OC4yYy42LDAsMS4xLjIsMS42LjZsNyw3Yy40LjQsMSwuNiwxLjYuNmg1OC4yYzUuMSwwLDkuMy00LjEsOS4zLTkuM2gwdi01OGMwLS42LS4yLTEuMS0uNi0xLjZsLTctN2MtLjUtLjQtLjgtLjktLjgtMS41Wk0xMDUuNiwxMDYuNmgtNTcuN2MtLjcsMC0xLjMtLjYtMS4zLTEuM3YtNTcuNmMwLS43LjYtMS4zLDEuMy0xLjNoNTcuN2MuNywwLDEuMy42LDEuMywxLjN2NTcuNmMuMS43LS41LDEuMy0xLjMsMS4zWiIvPgo8L3N2Zz4K",rdns:"sh.frame"};function f(){try{if(a){const s=Object.freeze({info:N,provider:a}),e=new CustomEvent("eip6963:announceProvider",{detail:s});window.dispatchEvent(e)}}catch(s){console.error("Frame could not dispatch EIP-6963 broadcast announce provider event",s)}}window.addEventListener("eip6963:requestProvider",()=>{f()});f();b();document.addEventListener("readystatechange",s=>{document.readyState==="interactive"&&b()});const p={getChainId:async()=>await window.ethereum.doSend("eth_chainId",[],void 0,!1)};window.addEventListener("message",async s=>{const e=s.data;if(s&&s.source===window&&e&&e.type==="embedded:action"&&window.self===window.top&&e.action){const n=e.action;if(p[n.type]){const t=await p[n.type](n),i={method:"embedded_action_res",params:[n,t]};window.postMessage({type:"eth:send",payload:i},window.location.origin)}else console.warn(`Could not find embedded action ${n.type}`)}});
